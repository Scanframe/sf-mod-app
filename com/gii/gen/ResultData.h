#pragma once

#include "misc/gen/RangeManager.h"
#include "ResultDataStorage.h"
#include "ResultDataTypes.h"
#include "ResultDataHandler.h"

namespace sf
{

/**
 * @brief
 * Class for creating and referencing global created data called result data.
 * This class allows linking of member functions of other classes to handle
 * events generated by the data server and client.
 */
class _GII_CLASS ResultData :public InformationBase, public ResultDataTypes
{
	public:
		/**
		 * Default constructor.
		 */
		ResultData();

		/**
		 * Copy constructor.
		 * @param v
		 */
		ResultData(const ResultData& v);

		/**
		 * Constructor for creating an instance that attaches to an existing reference with ID 'id'.
		 * @param id
		 * @param set_did
		 */
		explicit ResultData(id_type id, bool set_did = false);

		/**
		 * Constructor for creating a completely new reference from a string.
		 * If the ID already exists it is attached to the existing one.
		 * @param definition
		 */
		explicit ResultData(const std::string& definition);

		/**
		 * Same as above but now using the passed offset for the formed ID.
		 * @param definition
		 * @param id_ofs
		 */
		ResultData(const std::string& definition, ResultData::id_type id_ofs);

		/**
		 * Creates a new result using the passed definition structure.
		 * @param definition
		 */
		explicit ResultData(const Definition* definition);

		/**
		 * Destructor
		 */
		~ResultData() override;

		/**
		 * Creates a new TResultDataReference from a setup String for this instance.
		 * @return
		 */
		bool setup(const std::string& definition);

		/**
		 * Same as above but uses an offset for the ID in the string.
		 * @param definition
		 * @param id_ofs
		 * @return
		 */
		bool setup(const std::string& definition, long id_ofs);

		/**
		 * Creates a new TResultDataReference from a structure for this instance.
		 * @param definition
		 * @return
		 */
		bool setup(const Definition* definition);

		/**
		 * Set reference to other result
		 * @param r
		 * @return
		 */
		bool setup(const ResultData& r);

		/**
		 * Set reference to other result by ID.
		 * @param id
		 * @param set_did
		 * @return
		 */
		bool setup(ResultData::id_type id, bool set_did = false);

		/**
		 * Gets the setup string for this result
		 * @return
		 */
		[[nodiscard]] std::string getSetupString() const;

		/**
		 * Sets the accessible range.
		 * If the range in increased an event is generated for all users.
		 * When skip_self is 'true' this instance is skipped in the users list.
		 * Returns true if a change was made to the range and false if not.
		 * This function calls Reserve if needed to match the given range.
		 * @param rng
		 * @param skip_self
		 * @return
		 */
		bool setAccessRange(const Range& rng, bool skip_self = false);

		/**
		 * @see #setAccessRange()
		 * @param stop
		 * @param skip_self
		 * @return
		 */
		bool setAccessRange(long stop, bool skip_self = false);

		/**
		 * Sets a event handler for this instance
		 * @param handler Passing NULL wil disable the link.
		 */
		void setHandler(ResultDataHandler* handler);

		/**
		 * Returns the linked handler hook object.
		 * @return
		 */
		[[nodiscard]] const ResultDataHandler* getHandler() const
		{
			return _handler;
		}

		/**
		 * Make this instance owner of this result
		 */
		void makeOwner();

		/**
		 * Return a pointer to the owner.
		 * @return
		 */
		ResultData& getOwner();

		/**
		 * Checks if this is the owner of this result
		 * @return
		 */
		[[nodiscard]] bool isOwner() const;

		// Sets the UserData void pointer data member.
		void setUserData(void* data);

		/**
		 * Gets the UserData void pointer data member.
		 * @return
		 */
		[[nodiscard]] void* getUserData() const;

		/**
		 * Returns if the result data instance is valid.
		 * @return
		 */
		[[nodiscard]] bool isValid() const;

		// Returns the correction offset for each value to get the real value.
		[[nodiscard]] unsigned long getValueOffset() const;

		// Returns the value range taking the significant bits into account.
		[[nodiscard]] unsigned long getValueRange() const;

		/**
		 * Returns the value derived from a buffer data pointer mapped to the
		 * appropriate type and corrected with the results offset.
		 * @param data
		 * @return
		 */
		int32_t getValue(const void* data) const;

		/**
		 * Same as getValue but no offset is added.
		 * @param data
		 * @return
		 */
		uint32_t getValueU(const void* data) const;

		/**
		 * Same as above but now from the instance at the passed index
		 * from the array of the results type.
		 * @param idx
		 * @param data
		 * @return
		 */
		int32_t getValue(size_type idx, const void* data) const;

		/**
		 * Same as getValue but no offset is added.
		 * @param idx
		 * @param data
		 * @return
		 */
		uint32_t getValueU(size_type idx, const void* data) const;

		/**
		 * Returns the result id
		 * @return
		 */
		[[nodiscard]] id_type getId() const;

		/**
		 * Returns the FDesiredId data member value.
		 * @return
		 */
		[[nodiscard]] id_type getDesiredId() const;

		/**
		 * Returns the sequential Id of this instance.
		 * @return
		 */
		[[nodiscard]] id_type getSeqId() const;

		/**
		 * Returns the resultdata name which is default the full resultdata path name.
		 * When levels is 'n' and larger then zero the last 'n' levels are returned.
		 * When levels is 'n' and smaller then zero the first 'n' levels are ommitted.
		 * @param levels
		 * @return
		 */
		[[nodiscard]] std::string getName(int levels = 0) const;

		/**
		 * Returns the amount of levels of the full name path.
		 * @return
		 */
		[[nodiscard]] int getNameLevelCount() const;

		/**
		 * Returns result description
		 * @return
		 */
		[[nodiscard]] std::string getDescription() const;

		/**
		 * Sets the desired id member variable to the current reference id.
		 */
		void setDesiredId();

		/**
		 * Sets the desired id member variable to the passed id.
		 * If the passed 'id' is zero the automatic attachment mechanism is disabled.
		 * @param id
		 */
		void setDesiredId(long id);

		/**
		 * Sets the data for this instance for user purposes.
		 * @param data
		 */
		void setData(uint64_t data);

		/**
		 * Gets the data for this instance for user purposes set with setData().
		 * @return
		 */
		[[nodiscard]] uint64_t getData() const;

		/**
		 * Returns the usage count of this result reference.
		 * @return
		 */
		[[nodiscard]] unsigned getUsageCount() const;

		/**
		 * Returns reference to underlying multi threaded safe storage class.
		 * To access the data a local data store class must be wrapped around it.
		 * @return
		 */
		[[nodiscard]] const ResultDataStorage& getDataStore() const;

		/**
		 * Returns the size in bytes needed for buffers for reading or writing the amount of blocks.
		 * @param blocks
		 * @return
		 */
		[[nodiscard]] size_type getBufferSize(size_type blocks) const;

		/**
		 * Returns the size in bytes needed for buffers for reading or writing the range.
		 * @param rng Range depicting the block size.
		 * @return
		 */
		[[nodiscard]] size_type getBufferSize(const Range& rng) const;

		/**
		 * Returns the block size.
		 * This is not in bytes!
		 * @return
		 */
		[[nodiscard]] size_type getBlockSize() const;

		/**
		 * Returns the accessible block count which does not mean it is valid.
		 * @return
		 */
		[[nodiscard]] size_type getBlockCount() const;

		/**
		 * Returns the segment size in blocks.
		 * @return Blocks in a single segment.
		 */
		[[nodiscard]] long getSegmentSize() const;

		/**
		 * Returns the accessible segment count.
		 * @return Amount of segments.
		 */
		[[nodiscard]] long getSegmentCount() const;

		/**
		 * Get the amount of reserved blocks.
		 * @return Amount of blocks
		 */
		[[nodiscard]] long getReservedBlockCount() const;

		/**
		 * Returns the total reserved size in bytes for this instance.
		 * Taking recycling into account.
		 * Don't use this to see if enough data is reserved or so.
		 * @return Amount of blocks.
		 */
		[[nodiscard]] long getReservedSize() const;

		/**
		 * Returns true if it succeeded to read the data.
		 * This function also calls #isRangeValid to check the validity of the data.
		 * If not this function returns false.
		 * @param ofs Offset in blocks as start to read.
		 * @param sz Size in blocks to read.
		 * @param dest Destination to write the data to.
		 * @param force When true the function won't check the validity of the range but only the block count.
		 * @return
		 */
		bool blockRead(long ofs, long sz, void* dest, bool force = false) const;

		/**
		 * @see #blockRead()
		 */
		bool blockRead(const Range& rng, void* dest, bool force = false) const;

		/**
		 * Reads an range from an index result.
		 * @param ofs
		 * @param range
		 * @return
		 */
		bool readIndexRange(long ofs, Range& range);

		/**
		 * Reads an range from an index result.
		 * @param idxrng
		 * @param range
		 * @return
		 */
		bool readIndexRange(const Range& idxrng, Range& range);

		/**
		 * Returns true if the specified range is valid.
		 * @param ofs
		 * @param sz
		 * @return
		 */
		[[nodiscard]] bool isRangeValid(long ofs, long sz) const;

		/**
		 * @see #isRangeValid
		 */
		[[nodiscard]] bool isRangeValid(const Range& rng) const;

		/**
		 * Returns true if the specified index range is valid.
		 * @param rng Range being tested.
		 * @return True on valid.
		 */
		[[nodiscard]] bool isIndexRangeValid(const Range& rng) const;

		/**
		 * Returns the accessible block range where the stop value
		 * is the same as the result of calling 'getBlockCount'.
		 * @return
		 */
		[[nodiscard]] const Range& getAccessRange() const;

		/**
		 * Returns a copy of of the client requests that are out for data for the owner.
		 * This list is already narrowed down.
		 * @param reqlist
		 * @return
		 */
		bool getRequests(Range::Vector& reqlist) const;

		/**
		 * Returns the ranges which are bound by the segment bounds.
		 * The ID field of the range caries the segment index.
		 * @param req_list
		 * @return
		 */
		bool getSplitRequests(Range::Vector& req_list) const;

		/**
		 * This function reports the status as a text in a 'ostream'.
		 * @param os
		 * @return
		 */
		std::ostream& reportStatus(std::ostream& os) const;

		/**
		 * Returns the Transaction Id used in requests of data.
		 * @return
		 */
		[[nodiscard]] long getTransId() const;

		/**
		 * Checks if the process is the owner of the data of this result.
		 * @return
		 */
		[[nodiscard]] bool isDataOwner() const;

		/**
		 * This function is used when two processes share the same data.
		 * Sets the owner ship of the data.
		 * This is only possible when segments are not allocated yet.
		 * Returns the status of the ownership.
		 * @param shared
		 * @return
		 */
		[[nodiscard]] bool setDataOwner(bool shared) const;

		/**
		 * Returns true if it succeeds to write/store the data.
		 * If this instance is not the owner of the reference it returns false.
		 * This function caches all events and are committed when
		 * 'CommitCommitValidations' is called.
		 * Passing -1 as offset means that the data is appended and getBlockCount
		 * is called internally to get the offset.
		 * @param ofs
		 * @param sz
		 * @param src
		 * @param auto_reserve
		 * @return
		 */
		bool blockWrite(long ofs, long sz, const void* src, bool auto_reserve = false);

		/**
		 * @see #blockWrite()
		 * @param rng
		 * @param dest
		 * @param auto_reserve
		 * @return
		 */
		bool blockWrite(const Range& rng, const void* dest, bool auto_reserve = false);

		/**
		 * When this function is called users of this instance are notified of all writes made to this instance.
		 * @param skip_self
		 */
		void commitValidations(bool skip_self = false);

		/**
		 * Set the amount of reserved blocks and returns true on success.
		 * Generates an event to all users using the same reference.
		 * @param sz
		 * @param skip_self
		 * @return
		 */
		bool setReservedBlockCount(long sz, bool skip_self = false);

		/**
		 * Clears all the valid ranges of this instance.
		 * It generates an event reCLEAR before it is actual cleared.
		 * Returns true if clear had any effect if not no event was generated.
		 * @param skip_self
		 * @return
		 */
		bool clearValidations(bool skip_self = false);

		/**
		 * Must be called if a range of memory blocks is validated by writing to it.
		 * Automatically called by '#blockWrite()'.
		 * @param ofs
		 * @param sz
		 */
		void validateRange(long ofs, long sz);

		/**
		 * @see #validateRange()
		 * @param r
		 */
		void validateRange(Range r);

		/**
		 * @see #validateRange()
		 * @param rl
		 */
		void validateRange(const Range::Vector& rl);

		/**
		 * Requests the owner to validate a range.
		 * Returns true if the request was excepted.
		 * Returns false if the request was rejected if the range is already valid or
		 * if the range is not within the current accessible range.
		 * @param ofs
		 * @param sz
		 * @return
		 */
		bool requestRange(long ofs, long sz);

		/**
		 * @see #requestRange()
		 * @param r
		 */
		bool requestRange(const Range& r);

		/**
		 * Same as request range but the start is decremented by 1.
		 * @param r
		 * @return
		 */
		bool requestIndexRange(const Range& r);

		/**
		 * Clears out standing requests for this instance.
		 * Can only be called on clients.
		 */
		void clearRequests();

		/**
		 * Returns true checks if a certain flag is set or combination of flags are all set.
		 * @param flag
		 * @return
		 */
		[[nodiscard]] bool isFlag(int flag) const;

		/**
		 * Sets a flag or multiple flags. Only allowed by owners.
		 * @param flag
		 * @param skip_self
		 * @return
		 */
		bool setFlag(int flag, bool skip_self);

		/**
		 * Unsets a flag or multiple flags. Only allowed by owners.
		 * @param flag
		 * @param skip_self
		 * @return
		 */
		bool unsetFlag(int flag, bool skip_self);

		/**
		 * Returns the current flags in a std::string form
		 * @return
		 */
		[[nodiscard]] std::string getCurFlagsString() const;

		/**
		 * Returns the original setup flags in a std::string form
		 * @return
		 */
		[[nodiscard]] std::string getFlagsString() const;

		/**
		 * Clears and updates the flags. Only allowed by owners.
		 * @param flag
		 * @param skip_self True when skipping its own handler.
		 * @return
		 */
		bool updateFlags(int flag, bool skip_self);

		/**
		 * Returns the flags at the time the instance was created.
		 *
		 */
		[[nodiscard]] long getFlags() const;

		/**
		 * Returns the current flags for this instance.
		 *
		 */
		[[nodiscard]] long getCurFlags() const;

		/**
		 * Returns type enumerate of given std::string
		 * @param type_str
		 * @return
		 */
		static EType getType(const char* type_str);

		/**
		 * Returns type std::string of given enumerate value
		 * @param type
		 * @return
		 */
		static const char* getType(EType type);

		/**
		 * Returns type enumerate of this result instance
		 *
		 */
		[[nodiscard]] EType getType() const;

		/**
		 * Returns the size of the type passed in 'type'.
		 * @param type
		 * @return
		 */
		static ResultData::size_type getTypeSize(EType type);

		/**
		 * Returns the size of the type of the current instance.
		 * @return
		 */
		[[nodiscard]] ResultData::size_type getTypeSize() const;

		/**
		 * Returns the significant bits of the type used for this result
		 * @return
		 */
		[[nodiscard]] unsigned getSignificantBits() const;

		/**
		 * Returns the amount of results in the system
		 * @return
		 */
		static size_type getResultDataCount();

		/**
		 * Returns the amount of result instances in the system
		 * @return
		 */
		static size_type getInstanceCount();

		/**
		 * Returns the 'p' item in the static result list
		 * @param p
		 * @return
		 */
		static const ResultData* getResultDataListItem(unsigned p);

		/**
		 * Returns result with the given id on error it returns zero result
		 * @param id
		 * @return
		 */
		static const ResultData& getResultDataById(ResultData::id_type id);

		/**
		 * Finds variable in vector with passed ID and returns a reference to it.
		 * If not found it returns ZeroResultData.
		 * @param id
		 * @param list
		 * @return
		 */
		static ResultData& getResultDataById(id_type id, Vector& list);

		/**
		 * @see #getResultDataById()
		 * @param id
		 * @param list
		 * @return
		 */
		static const ResultData& getResultDataById(id_type id, const Vector& list);

		/**
		 * Finds variable in vector with passed sequential ID and returns a
		 * reference to it. If not found it returns ZeroResultData.
		 * @param seq_id
		 * @param list
		 * @return
		 */
		static ResultData& getResultDataBySeqId(ResultData::id_type seq_id, Vector& list);

		/**
		 * @see #getResultDataBySequenceId()
		 * @param seq_id
		 * @param list
		 * @return
		 */
		static const ResultData& getResultDataBySequenceId(ResultData::id_type seq_id, const Vector& list);

		/**
		 * Returns the total amount of bytes reserved by all instances.
		 * @return
		 */
		static ResultData::size_type getTotalReservedSize();

		/**
		 * Reads multiple results from stream returns true if no error occurred
		 * on error returns false and line returns the error line in the stream
		 * @param is
		 * @param list
		 * @param err_line
		 * @return
		 */
		static bool create(std::istream& is, Vector& list = null_ref<Vector>(), int& err_line = null_ref<int>());

		/**
		 * Writes id and current access range and current flags to the stream.
		 * @param os
		 * @return
		 */
		bool writeUpdate(std::ostream& os) const;

		/**
		 * Read new multiple current access range and current flags are read from stream.
		 * If 'list' is other then a NULL_REF that list is used to seek the according variable instead of the global list.
		 * @param is
		 * @param skip_self
		 * @param list
		 * @return
		 */
		static bool readUpdate(std::istream& is, bool skip_self, Vector& list = null_ref<Vector>());

		/**
		 * Converts a std::string with flag characters to an integer
		 * @param flags
		 * @return
		 */
		static flags_type stringToFlags(const char* flags);

		/**
		 * Returns the passed flags in a std::string form
		 * @param flags
		 * @return
		 */
		static std::string getFlagsString(long flags);

		/**
		 * Assignment operator that attaches this instance to the same ResultDataReference as 'rd'.
		 * @param rd
		 * @return
		 */
		ResultData& operator=(const ResultData& rd);

		/**
		 * Comparison operator
		 * @param rd
		 * @return
		 */
		int operator==(const ResultData& rd) const;

		/**
		 * During events no instances should be deleted
		 * The destructor will be called but the data still exists
		 */
		void operator delete(void*); // NOLINT(misc-new-delete-overloads)

	private:
		/**
		 * Zero variable constructor.
		 */
		explicit ResultData(void*, void*);

		/**
		 * Function called by the setup function.
		 * @param ref
		 * @param segment_size
		 * @param block_size
		 * @return
		 */
		bool createDataStore(ResultDataReference* ref, size_type segment_size, size_type block_size);

		/**
		 * Initiate event for all instances of this result if params was set by  this param is ignored
		 * @param rng
		 * @param skip_self
		 * @return
		 */
		size_type emitLocalEvent(EEvent event, const Range& rng, bool skip_self = true);

		/**
		 * Initiate event for all result instances if param was set by setHandler this past param is used
		 * @param event
		 * @param rng
		 * @param skip_self
		 * @return
		 */
		size_type emitGlobalEvent(EEvent event, const Range& rng, bool skip_self = true);

		/**
		 * Function which checks the link before calling it.
		 * This is the only function which calls the Link handler directly.
		 * @param caller
		 * @param rng
		 */
		void emitEvent(EEvent ev, const ResultData& caller, const Range& rng);

		/**
		 * Get a reference by ID if not exist.
		 * @param id
		 * @return
		 */
		static ResultDataReference* getReferenceById(ResultData::id_type id);

		/**
		 * Function that scans all #ResultData instances for the passed link and removes it.
		 * @param handler
		 */
		static void removeHandler(ResultDataHandler* handler);

		/**
		 * Private function to attach e result reference
		 * @param ref
		 * @return
		 */
		bool attachRef(ResultDataReference* ref);

		/**
		 * Attaches all instances that have the desired id set as this one.
		 * @return
		 */
		unsigned attachDesired();

		/**
		 * Enables or disables recycling mode and flag. Does not generate an event.
		 * @param recycle
		 * @return True on success.
		 */
		bool recycleEnable(bool recycle);

		/**
		 * Reference to the actual data
		 */
		ResultDataReference* _reference{nullptr};
		/**
		 * Pointer to ResultDataEventHandler function
		 */
		ResultDataHandler* _handler{nullptr};
		/**
		 * This transfer ID member identifies this instance when an
		 * event is generated for a specific result as a result of a request made by this specific result.
		 * This value is set and reset  by the 'setHandler' member function.
		 */
		int64_t _transId{0};
		/**
		 * If this data member is non-zero it will be automatically re-attached to the reference when it is created.
		 */
		long _desiredId{0};
		/**
		 * Hold the pointer to any data assigned by using SetUserData.
		 */
		void* _userData{nullptr};
		/**
		 * Holds the instance data for user purposes set with setData() and got with getData().
		 */
		uint64_t _data{0};

	public:
		//
		// Undocumented debugging functions
		//
		static const char* getEventName(EEvent event);

		const ResultDataReference& GetRef()
		{
			return *_reference;
		}

		[[nodiscard]] const Range::Vector& getCommitList() const;

		[[nodiscard]] const Range::Vector& getValidatedList() const;

		/**
		 * Returns the accumulation of locks on segments.
		 * @return
		 */
		[[nodiscard]] size_type getSegmentLocks() const;

		/**
		 * Initiate event for all instances of this result
		 * If skip_self is 'true' this instance is left out of the list.
		 * @param event
		 * @param rng
		 * @param skip_self
		 * @return
		 */
		unsigned emitEvent(EEvent event, const Range& rng, bool skip_self = false);

		friend class ResultDataHandler;

		friend class ResultDataStatic;
};

inline
ResultData::ResultData(const ResultData& v)
{
	setup(v);
}

inline
ResultData::ResultData(ResultData::id_type id, bool set_did)
{
	setup(id, set_did);
}

inline
ResultData::ResultData(const std::string& definition)
{
	setup(definition, 0);
}

inline
ResultData::ResultData(const std::string& definition, ResultData::id_type id_ofs)
{
	setup(definition, id_ofs);
}

inline
ResultData::ResultData(const Definition* definition)
{
	setup(definition);
}

inline
bool ResultData::setup(const std::string& definition)
{
	return setup(definition, 0);
}

inline
bool ResultData::setup(const ResultData& r)
{
	auto* p = &r;
	setDesiredId(p ? r._desiredId : 0);
	return attachRef(p ? r._reference : nullptr);
}

inline
bool ResultData::setup(ResultData::id_type id, bool set_did)
{
	if (set_did)
	{
		setDesiredId(id);
	}
	return attachRef(getReferenceById(id));
}

inline
ResultData& ResultData::operator=(const ResultData& rd)
{
	if (this != &rd)
	{
		setup(rd);
	}
	return *this;
}

inline
void ResultData::setUserData(void* data)
{
	_userData = data;
}

inline
void* ResultData::getUserData() const
{
	return _userData;
}

inline
ResultData::id_type ResultData::getDesiredId() const
{
	return _desiredId;
}

inline
ResultData::size_type ResultData::getBufferSize(const Range& rng) const
{
	return getBufferSize(rng.getSize());
}

inline
bool ResultData::blockRead(const Range& rng, void* dest, bool force) const
{
	return blockRead(rng.getStart(), rng.getSize(), dest, force);
}

inline
bool ResultData::blockWrite(const Range& rng, const void* dest, bool auto_reserve)
{
	return blockWrite(rng.getStart(), rng.getSize(), dest, auto_reserve);
}

inline
long ResultData::getTransId() const
{
	return _transId;
}

inline
void ResultData::validateRange(long ofs, long sz)
{
	validateRange(Range(ofs, ofs + sz));
}

inline
bool ResultData::requestRange(long ofs, long sz)
{
	return requestRange(Range(ofs, ofs + sz));
}

inline
bool ResultData::setAccessRange(long stop, bool skip_self)
{
	return ResultData::setAccessRange(Range(0, stop), skip_self);
}


inline
ResultData::size_type ResultData::getTypeSize() const
{
	return getTypeSize(getType());
}

inline
const ResultData& ResultData::getResultDataById(ResultData::id_type id, const ResultData::Vector& list)
{
	return getResultDataById(id, const_cast<ResultData::Vector&>(list));
}

inline
const ResultData& ResultData::getResultDataBySequenceId(ResultData::id_type seq_id, const ResultData::Vector& list)
{
	return getResultDataById(seq_id, const_cast<ResultData::Vector&>(list));
}

inline
void ResultData::setData(uint64_t data)
{
	_data = data;
}

inline
uint64_t ResultData::getData() const
{
	return _data;
}

inline
int ResultData::operator==(const ResultData& rd) const
{
	return rd._reference == _reference && rd.isOwner() == isOwner();
}

/**
 * Stream operator for the setup std::string.
 */
_GII_FUNC std::ostream& operator<<(std::ostream& os, const ResultData&);

/**
 * Stream operator for setting up this instance with a setup std::string.
 */
_GII_FUNC  std::istream& operator>>(std::istream& is, ResultData&);

}
