#pragma once

#include "misc/gen/RangeManager.h"
#include "FileMappedStorage.h"
#include "ResultDataTypes.h"
#include "ResultDataHandler.h"
#include "ResultDataReference.h"

namespace sf
{

/**
 * @brief Class for creating and referencing global created data called result data.
 * This class allows linking of member functions of other classes to handle
 * events generated by the data server and client.
 */
class _GII_CLASS ResultData :public InformationBase, public ResultDataTypes
{
	public:
		/**
		 * @brief Must be called to initialize the statics which this class depends on.
		 */
		static void initialize();

		/**
		 * @brief Called when terminating the application.
		 */
		static void deinitialize();

		/**
		 * @brief Default constructor.
		 */
		ResultData();

		/**
		 * @brief Copy constructor.
		 *
		 * Sets the reference as the passed instance.
		 * @param rd Instance to having the reference to assign.
		 */
		ResultData(const ResultData& rd);

		/**
		 * @brief Constructor for creating an instance that attaches to an existing reference by id.
		 *
		 * @param id Identifying number.
		 * @param set_desired When true the desired id is set as the passed id.
		 */
		explicit ResultData(id_type id, bool set_desired = false);

		/**
		 * @brief Constructor for creating a completely new reference.
		 *
		 * @param definition Comma separated string with fields according the #EField enumerate.
		 * @param id_ofs Offset added to the id passed in the string.
		 */
		explicit ResultData(const std::string& definition, ResultData::id_type id_ofs = 0);

		/**
		 * @brief Creates a new result using the passed definition structure.
		 *
		 * @param definition Definition structure.
		 * @param id_ofs Offset given to the id.
		 */
		explicit ResultData(const Definition& definition, ResultData::id_type id_ofs = 0);

		/**
		 * @brief Overridden destructor.
		 */
		~ResultData() override;

		/**
		 * @brief Creates a new reference from a setup string for this instance.
		 *
		 * @param definition Comma separated string with fields according the #EField enumerate.
		 * @param id_ofs Offset for the id in the definition string.
		 * @return True when successful.
		 */
		bool setup(const std::string& definition, id_type id_ofs = 0);

		/**
		 * @brief Creates a new TResultDataReference from a structure for this instance.
		 *
		 * @param definition Definition structure.
		 * @param id_ofs Offset given to the definition id.
		 * @return True when successful.
		 */
		bool setup(const Definition& definition, id_type id_ofs);

		/**
		 * @brief Sets reference as the reference in the passed instance.
		 *
		 * @param rd Instance to get the source reference from.
		 * @return True when successful.
		 */
		bool setup(const ResultData& rd);

		/**
		 * @brief Sets reference to other by id.
		 *
		 * The global list of references is searched for the passed id and referenced when found.
		 * When found event #reIdChanged is emitted.
		 * When the desired id was set and changed the #reDesiredId event is emitted.
		 * Cannot be used for local variables.
		 * @param id Identifier.
		 * @param set_did When true the desired id is set to the passed 'id'.
		 * @return True when found and referenced.
		 */
		bool setup(ResultData::id_type id, bool set_did = false);

		/**
		 * @brief Gets the setup string for this instance.
		 *
		 * @return Setup string as initially created.
		 */
		[[nodiscard]] std::string getSetupString() const;

		/**
		 * @brief Sets the accessible range.
		 *
		 * When needed the method calls #setReservedBlockCount() to match the given range emitting the #reReserve event.
		 * When the range is increased an #reAccessChange event is emitted.
		 * @param rng Accessible range in blocks.
		 * @param skip_self True when skipping this instance's handler.
		 * @return True when a change was made to the range and false if not.
		 */
		bool setAccessRange(const Range& rng, bool skip_self = false);

		/**
		 * @brief Same as #setAccessRange where the start value is default 0.
		 *
		 * @param stop End of range in blocks.
		 * @param skip_self True when skipping this instance's handler.
		 * @return True when a change was made to the range and false if not.
		 * @see #setAccessRange(const Range& rng, bool skip_self = false)
		 */
		bool setAccessRange(Range::size_type stop, bool skip_self = false);

		/**
		 * @brief Sets a event handler for this instance.
		 *
		 * @param handler Passing NULL will disable the link.
		 */
		void setHandler(ResultDataHandler* handler);

		/**
		 * @brief Gets the handler pointer of this instance set with #setHandler().
		 *
		 * @return Handler object or NULL when not assigned.
		 * @see #setHandler()
		 */
		[[nodiscard]] const ResultDataHandler* getHandler() const
		{
			return _handler;
		}

		/**
		 * @brief Make this instance owner of this result.
		 */
		void makeOwner();

		/**
		 * @brief Gets reference of the owning instance.
		 */
		ResultData& getOwner();

		/**
		 * @brief Checks if this is the owner of this result.
		 *
		 * @return True when this instance is the owning instance.
		 */
		[[nodiscard]] bool isOwner() const;

		/**
		 * @brief Sets the void pointer data member for general purposes to cast in a handler.
		 *
		 * @param data Pointer
		 */
		void setUserData(void* data);

		/**
		 * @brief Gets the UserData void pointer data member.
		 *
		 * @return Pointer to cast.
		 */
		[[nodiscard]] void* getUserData() const;

		/**
		 * @brief Gets the instance validity.
		 *
		 * @return True when valid.
		 */
		[[nodiscard]] bool isValid() const;

		/**
		 * @brief Returns the correction offset for each value to get the real value.
		 *
		 * @return Offset of the value.
		 */
		[[nodiscard]] data_type getValueOffset() const;

		/**
		 * @brief Gets the value range (max) taking the significant bits into account.
		 *
		 * @return Max value.
		 */
		[[nodiscard]] data_type getValueRange() const;

		/**
		 * @brief Returns the value derived from a buffer data pointer mapped to the
		 * appropriate type and corrected with the results offset.
		 *
		 * @param data Pointer to element.
		 * @return Signed integer data value.
		 */
		sdata_type getValue(const void* data) const;

		/**
		 * @brief Same as getValue but no offset is added.
		 *
		 * @param data Pointer to element.
		 * @return Unsigned integer data value.
		 */
		data_type getValueU(const void* data) const;

		/**
		 * @brief Same as #getValue() but now from the instance at the passed index from the array of the results type.
		 *
		 * @param idx Index offset into the data.
		 * @param data Pointer to element.
		 * @return Signed integer data value.
		 */
		sdata_type getValue(size_type idx, const void* data) const;

		/**
		 * @brief Same as getValue but no offset is added.
		 *
		 * @param idx
		 * @param data
		 * @return
		 */
		data_type getValueU(size_type idx, const void* data) const;

		/**
		 * @brief Returns the result identifier.
		 * @return ID integer value.
		 */
		[[nodiscard]] id_type getId() const;

		/**
		 * @brief Gets the desired id data member value.
		 * @return Desired identifier.
		 */
		[[nodiscard]] id_type getDesiredId() const;

		/**
		 * @brief Gets the sequential Id of this instance.
		 * @return Sequential Id
		 */
		[[nodiscard]] id_type getSequenceId() const;

		/**
		 * @brief Gets the result data name which is default the full result data path name.
		 *
		 * When levels is 'n' and larger then zero the last 'n' levels are returned.
		 * When levels is 'n' and smaller then zero the first 'n' levels are omitted.
		 * @param levels
		 * @return
		 */
		[[nodiscard]] std::string getName(int levels = 0) const;

		/**
		 * @brief Gets the amount of levels of the fullname path.
		 *
		 * @return Name string
		 */
		[[nodiscard]] int getNameLevelCount() const;

		/**
		 * @brief Gets the instance description.
		 *
		 * @return Name string
		 */
		[[nodiscard]] std::string getDescription() const;

		/**
		 * @brief Sets the desired id member variable to the current reference id.
		 */
		void setDesiredId();

		/**
		 * @brief Sets the desired id member variable to the passed id.
		 *
		 * If the passed 'id' is zero the automatic attachment mechanism is disabled.
		 * @param id DesiredId
		 */
		void setDesiredId(id_type id);

		/**
		 * @brief Sets the data for this instance for user purposes.
		 *
		 * @param data
		 */
		void setData(uint64_t data);

		/**
		 * @brief Gets the data for this instance for user purposes set with #setData().
		 */
		[[nodiscard]] uint64_t getData() const;

		/**
		 * @brief Gets the usage count of this result reference.
		 * @return Amount of instances.
		 */
		[[nodiscard]] size_type getUsageCount() const;

		/**
		 * @brief Returns reference to underlying multi-threaded safe storage class.
		 *
		 * To access the data a local data store class must be wrapped around it.
		 * @return Reference to the file map storage class.
		 */
		[[nodiscard]] const FileMappedStorage& getDataStore() const;

		/**
		 * @brief Gets the size in bytes needed for buffers for reading or writing the amount of blocks.
		 * @param blocks Amount of blocks.
		 * @return Size of the buffer in Bytes.
		 */
		[[nodiscard]] size_type getBufferSize(size_type blocks) const;

		/**
		 * @brief Gets the size in bytes needed for buffers for reading or writing the range.
		 * @param rng Range depicting the block size.
		 * @return Size of the buffer in Bytes.
		 */
		[[nodiscard]] size_type getBufferSize(const Range& rng) const;

		/**
		 * @brief Gets the block size in bytes.
		 *
		 * @return Size of block in bytes.
		 */
		[[nodiscard]] size_type getBlockSize() const;

		/**
		 * @brief Gets the accessible block count which does not mean it is valid.
		 *
		 * @return Amount of blocks.
		 */
		[[nodiscard]] Range::size_type getBlockCount() const;

		/**
		 * @brief Gets the segment size in blocks.
		 *
		 * @return Blocks in a single segment.
		 */
		[[nodiscard]] FileMappedStorage::size_type getSegmentSize() const;

		/**
		 * @brief Gets the accessible segment count.
		 *
		 * @return Amount of segments.
		 */
		[[nodiscard]] FileMappedStorage::size_type getSegmentCount() const;

		/**
		 * @brief Get the amount of reserved blocks.
		 *
		 * @return Amount of blocks
		 */
		[[nodiscard]] FileMappedStorage::size_type getReservedBlockCount() const;

		/**
		 * @brief Returns the total reserved size in bytes for this instance.
		 *
		 * Taking recycling into account. Don't use this to see if enough data is reserved or so.
		 * @return Amount of blocks.
		 */
		[[nodiscard]] FileMappedStorage::size_type getReservedSize() const;

		/**
		 * @brief Reads blocks from the storage using an offset.
		 *
		 * This function also calls #isRangeValid() to check the validity of the data.
		 * @param ofs Offset in blocks as start to read.
		 * @param sz Size in blocks to read.
		 * @param dest Destination to write the data to.
		 * @param force When true the function won't check the validity of the range but only the block count.
		 * @return True if it succeeded to read the data.
		 */
		bool blockRead(Range::size_type ofs, Range::size_type sz, void* dest, bool force = false) const;

		/**
		 * @brief Reads a range of blocks from storage.
		 *
		 * This function also calls #isRangeValid() to check the validity of the data.
		 * @param rng Range of blocks to read.
		 * @param dest Destination to write the data to.
		 * @param force When true the function won't check the validity of the range but only the block count.
		 * @return True on success false on failure and not valid.
		 * @see #blockRead()
		 */
		bool blockRead(const Range& rng, void* dest, bool force = false) const;

		/**
		 * @brief Reads an range when this instance holds indices.
		 *
		 * An index instance groups blocks together for processing/imaging purposes.
		 * @param ofs Offset in the storage container to read the index range.
		 * @param range Resulting range that was read.
		 * @return True on success false on failure and not valid.
		 */
		bool readIndexRange(Range::size_type ofs, Range& range);

		/**
		 * @brief Reads an range when this instance holds indices.
		 *
		 * @param index Range pointing to the first index and the last index value to read.
		 * @param range Resulting range that was read.
		 * @return True on success false on failure and not valid.
		 */
		bool readIndexRange(const Range& index, Range& range);

		/**
		 * @brief Checks if the passed block range depicted by offset and size is valid to access/read.
		 *
		 * @param ofs Offset in blocks.
		 * @param sz Size in blocks.
		 * @return True when the passed range is valid to read.
		 */
		[[nodiscard]] bool isRangeValid(Range::size_type ofs, Range::size_type sz) const;

		/**
		 * @brief Checks if the passed block range is valid to access/read.
		 *
		 * @param rng Range in blocks.
		 * @return True when the passed range is valid to read.
		 * @see #isRangeValid()
		 */
		[[nodiscard]] bool isRangeValid(const Range& rng) const;

		/**
		 * @brief Gets if the specified index range is valid.
		 *
		 * @param rng Index range being validated.
		 * @return True when valid.
		 */
		[[nodiscard]] bool isIndexRangeValid(const Range& rng) const;

		/**
		 * @brief Gets the accessible block range where the stop value.
		 * is the same as the result of calling 'getBlockCount'.
		 *
		 * @return Accessible range.
		 */
		[[nodiscard]] const Range& getAccessRange() const;

		/**
		 * @brief Returns a copy of of the client requests that are out for data for only the owner.
		 *
		 * This list is already narrowed down to essential ranges.
		 * @param requests Returned ranges of out standing current requests.
		 * @return True on success.
		 */
		bool getRequests(Range::Vector& requests) const;

		/**
		 * @brief Returns the ranges which are bound by the segment bounds.
		 *
		 * @param req_list
		 * @return True when successful.
		 */
		bool getSplitRequests(Range::Vector& req_list) const;

		/**
		 * @brief Reports the status as in the passed 'std::ostream'.
		 */
		std::ostream& reportStatus(std::ostream& os) const;

		/**
		 * @brief Gets the transaction id used in requests of data.
		 *
		 * @return The transaction id.
		 */
		[[nodiscard]] Range::id_type getTransId() const;

		/**
		 * @brief For owners to writes data to storage in using an offset and size in blocks.
		 *
		 * Written data needs to be committed using #commitValidations() which emits the events to all event handlers.
		 * Passing #npos as offset means that the data is appended and getBlockCount is called internally to get the offset.
		 * @param ofs When the value is #npos the data is appended.
		 * @param sz Size in blocks to write.
		 * @param src Source pointer to data to read from.
		 * @param auto_reserve Reserve file mapped memory when needed.
		 * @return True if it succeeds to write/store the data.
		 */
		bool blockWrite(Range::size_type ofs, Range::size_type sz, const void* src, bool auto_reserve = false);

		/**
		 * @brief For owners to writes data to storage in using an range in blocks.
		 *
		 * Written data needs to be committed using #commitValidations() which emits the events to all event handlers.
		 * @param rng Range to write in blocks.
		 * @param src Source pointer to data to read from.
		 * @param auto_reserve Reserve file mapped memory when needed.
		 * @see #blockWrite()
		 */
		bool blockWrite(const Range& rng, const void* src, bool auto_reserve = false);

		/**
		 * @brief Commits all validated ranges and to notifies assigned handlers.
		 *
		 * Emits the #reCommitted event to all handlers of this instance.
		 * @param skip_self True when skipping this instance's handler.
		 * @see #blockWrite()
		 */
		size_type commitValidations(bool skip_self = false);

		/**
		 * @brief Sets the amount of blocks to reserve only for owners.
		 *
		 * This method is called underwater when 'auto_reserve' is true in a call to #blockWrite().
		 * Emits event #reReserve to all instance handlers.
		 * @param sz Blocks to reserve.
		 * @param skip_self True when skipping this instance's handler.
		 * @return True when successful.
		 */
		bool setReservedBlockCount(Range::size_type sz, bool skip_self = false);

		/**
		 * @brief Clears all the valid ranges of this instance.
		 *
		 * It generates an event #reClear before it is actual cleared.
		 * @param skip_self True when skipping this instance's handler.
		 * @return True when clear had any effect if not no event was generated.
		 */
		bool clearValidations(bool skip_self = false);

		/**
		 * @brief Adds a validated range of blocks for committing later. Only available for owners.
		 *
		 * This method is useful when file mapped storage is written when locking it in memory
		 * when not using method #blockWrite() which implies this.
		 * @param ofs Offset in blocks.
		 * @param sz Size in blocks.
		 * @see #commitValidations()
		 */
		void validateRange(Range::size_type ofs, Range::size_type sz);

		/**
		 * @brief Adds a validated range of blocks for committing later. Only available for owners.
		 *
		 * This method is useful when file mapped storage is written when locking it in memory
		 * when not using method #blockWrite() which implies this.
		 * @param rng Range blocks.
		 * @see #commitValidations()
		 */
		void validateRange(Range rng);

		/**
		 * @brief Like #validateRange() but for a vector/list of ranges.
		 *
		 * @param rl List of ranges.
		 *
		 * @see #validateRange()
		 */
		void validateRange(const Range::Vector& rl);

		/**
		 * @brief Requests the a range using offset and size in blocks to validate.
		 *
		 * Emits event #reGetRange to the owner when a handler is assigned to it.
		 * Returns false when the request was rejected by the range manager due to being already valid or
		 * when the range is not within the current accessible range.
		 * @param ofs Offset in blocks.
		 * @param sz Size in blocks.
		 * @return True when the request was excepted.
		 */
		bool requestRange(Range::size_type ofs, Range::size_type sz);

		/**
		 * @brief Requests the a range in blocks to validate.
		 *
		 * @param rng Range in blocks.
		 * @return True when the request was excepted.
		 * @see #requestRange()
		 */
		bool requestRange(const Range& rng);

		/**
		 * @brief Same as #requestRange() but for when this instance is an index.
		 *
		 * @param rng Requested index range.
		 * @return True when the request was excepted.
		 * @see #requestRange()
		 */
		bool requestIndexRange(const Range& rng);

		/**
		 * @brief Clears the out standing requests for only this instance.
		 *
		 * Enables making fresh start in events.
		 */
		void clearRequests();

		/**
		 * @brief Check if a certain flag or flags (mask) are set.
		 *
		 * @param flag One or a combination of flags.
		 * @return True when the flag is or are set.
		 */
		[[nodiscard]] bool isFlag(int flag) const;

		/**
		 * @brief Sets a flag or multiple flags allowed by owners only.
		 * @param flag One or a combination of flags.
		 * @param skip_self True when skipping this instance's handler.
		 * @return True when successful.
		 */
		bool setFlag(int flag, bool skip_self);

		/**
		 * @brief Unsets a flag or multiple flags allowed by owners only.
		 * @param flag One or a combination of flags.
		 * @param skip_self True when skipping this instance's handler.
		 * @return True when successful.
		 */
		bool unsetFlag(int flag, bool skip_self);

		/**
		 * @brief Gets the current flags as a string.
		 *
		 * @return Flags string.
		 */
		[[nodiscard]] std::string getCurFlagsString() const;

		/**
		 * @brief Gets the original setup flags as a string.
		 *
		 * @return Flags string.
		 */
		[[nodiscard]] std::string getFlagsString() const;

		/**
		 * @brief Sets a new set flags for this instance allowed by owners only.
		 *
		 * @param flag One or a combination of flags.
		 * @param skip_self True when skipping this instance's handler.
		 * @return True when successful.
		 */
		bool updateFlags(int flag, bool skip_self);

		/**
		 * @brief Gets the set of flags at setup time.
		 * @return
		 */
		[[nodiscard]] flags_type getFlags() const;

		/**
		 * @brief Gets the current flags of this instance.
		 *
		 * @return One or a combination of flags.
		 */
		[[nodiscard]] flags_type getCurFlags() const;

		/**
		 * @brief Gets the type from the passed string name.
		 *
		 * @param type String depicting a data type like 'INT32'.
		 * @return #rtInvalid when not existing and the correct type otherwise.
		 */
		static EType getType(const char* type);

		/**
		 * @brief Gets the string typename of the passed enumerate value.
		 *
		 * @param type Enumerate value.
		 * @return Typename string.
		 */
		static const char* getType(EType type);

		/**
		 * @brief Gets current type of the instance.
		 * @return Enumerate type value.
		 */
		[[nodiscard]] EType getType() const;

		/**
		 * @brief Gets the size of the passed enumerate type value.
		 *
		 * @param type Enumerate type value.
		 * @return Size in bytes.
		 */
		static ResultData::size_type getTypeSize(EType type);

		/**
		 * @brief Gets the byte size of this instance's type.
		 * @return Size in bytes.
		 */
		[[nodiscard]] ResultData::size_type getTypeSize() const;

		/**
		 * @brief Gets the significant bits of the type used for this result
		 * @return Number of bits.
		 */
		[[nodiscard]] unsigned getSignificantBits() const;

		/**
		 * @brief Gets the amount of references in the system.
		 *
		 * In fact the amount references in the system excluding the zero one.
		 * @return Amount of references.
		 */
		static size_type getCount();

		/**
		 * @brief Gets the amount of result data instances in the system.
		 *
		 * @return Amount of clients and servers combined.
		 */
		static size_type getInstanceCount();

		/**
		 * @brief Gets a list of owner instances available.
		 *
		 * Useful in populating a selection dialog.
		 * @return Vector of instance pointers.
		 */
		static Vector getList();

		/**
		 * @brief Gets the name of the passed field enumerate #EField.
		 */
		static std::string getFieldName(int field);

		/**
		 * @brief Gets instance with the given id otherwise the zero instance.
		 *
		 * @param id Identifier integer.
		 * @return Reference to instance.
		 */
		static const ResultData& getInstanceById(ResultData::id_type id);

		/**
		 * @brief Finds instance in the passed vector having the passed id.
		 *
		 * When not found it te returns a reference to the zero instance.
		 * @param id Identifier.
		 * @param list
		 * @return Reference to instance.
		 * @see #sf::ResultDataStatic::zero()
		 */
		static const ResultData& getInstanceById(id_type id, const Vector& list);

		/**
		 * @brief Finds instance in passed vector. in vector with passed sequential ID and returns a
		 * reference to it. If not found it returns ZeroResultData.
		 * @param seq_id
		 * @param list
		 * @return
		 */
		static const ResultData& getInstanceBySequenceId(ResultData::id_type seq_id, const Vector& list);

		/**
		 * @brief Gets the total amount of bytes reserved by all instances.
		 * @return Amount in bytes.1
		 */
		static ResultData::size_type getTotalReservedSize();

		/**
		 * @brief Setup multiple instances from an input stream.
		 *
		 * Useful when reading a data file.
		 * @param is Input stream definition strings.
		 * @param list Returns vector of created instances.
		 * @param err_line Error line number.
		 * @return True when no error occurred.
		 */
		static bool create(std::istream& is, Vector& list = null_ref<Vector>(), int& err_line = null_ref<int>());

		/**
		 * @brief Writes id and current access range and current flags to the stream.
		 *
		 * Used in communication between applications.
		 * @param os Output stream.
		 * @return True when successful.
		 */
		bool writeUpdate(std::ostream& os) const;

		/**
		 * @brief Read new multiple current access range and current flags are read from stream.
		 *
		 * Used in communication between applications.
		 * @param is Input stream.
		 * @param skip_self When true no events are send to this instance itself.
		 * @param list Optional other list to use as source for instances.
		 * @return True when successful.
		 */
		static bool readUpdate(std::istream& is, bool skip_self, Vector& list = null_ref<Vector>());

		/**
		 * Fills a definition structure from a string.
		 * On failure the _valid field is set to false.
		 * @param str Definition string
		 * @return Definition structure
		 */
		static Definition getDefinition(const std::string& str);

		/**
		 * @brief Gets flags enumerate combination of the passed flags string.
		 *
		 * @param flags Flags string.
		 * @return Combination of enumerate #EFlag.
		 */
		static flags_type toFlags(const std::string& flags);

		/**
		 * @brief Gets flags string from the passed flags passed.
		 * @param flags Combination of enumerate #EFlag.
		 * @return String of flag characters.
		 */
		static std::string getFlagsString(flags_type flags);

		/**
		 * @brief Assigns the reference of the passed instance.
		 *
		 * Calls actually #setup(const ResultData& rd).
		 * @param rd Source instance
		 * @return Lvalue
		 */
		ResultData& operator=(const ResultData& rd);

		/**
		 * @brief Comparison operator.
		 *
		 * @param rd Result data to compare.
		 * @return True when the same.
		 */
		bool operator==(const ResultData& rd) const;

		/**
		 * @brief During events no instances should be deleted.
		 * The destructor will be called but the data still exist
		 */
		void operator delete(void*); // NOLINT(misc-new-delete-overloads)

	private:
		/**
		 * Zero variable constructor.
		 */
		explicit ResultData(void*, void*);

		/**
		 * Function called by the setup function.
		 * @param ref
		 * @param segment_size
		 * @param block_size
		 * @return
		 */
		bool createDataStore(ResultDataReference* ref, size_type segment_size, size_type block_size);

		/**
		 * @brief Initiate event for all instances of this result if params was set by  this param is ignored.
		 *
		 * @param rng Range passed to handler.
		 * @param skip_self When true no events are send to this instance itself.
		 * @return Amount of events sent.
		 */
		size_type emitLocalEvent(EEvent event, const Range& rng, bool skip_self = true);

		/**
		 * @brief Initiate event for all result instances if param was set by setHandler this past param is used.
		 *
		 * @param event event passed to handler.
		 * @param rng Range passed to handler.
		 * @param skip_self When true no events are send to this instance itself.
		 * @return Amount of events sent.
		 */
		size_type emitGlobalEvent(EEvent event, const Range& rng, bool skip_self = true);

		/**
		 * @brief Emits an event to a handler when one is assigned.
		 *
		 * This is the only function which calls this assigned instance handler directly.
		 * @param event Event passed to handler.
		 * @param caller Instance passed as caller to handler.
		 * @param rng Range passed to handler.
		 * @return True whe an event handler was actually called otherwise false.
		 */
		bool emitEvent(EEvent event, const ResultData& caller, const Range& rng);

		/**
		 * @brief Get a reference by ID if not exist.
		 *
		 * @param id Identifier.
		 * @return Reference.
		 */
		static ResultDataReference* getReferenceById(ResultData::id_type id);

		/**
		 * @brief Iterates all instances for the passed handler and removes it.
		 *
		 * @param handler Handler to remove.
		 */
		static void removeHandler(ResultDataHandler* handler);

		/**
		 * @brief Private function to attach the result to this reference replacing the existing one.
		 *
		 * @param ref Variable reference to attach to.
		 * @return True on success.
		 */
		bool attachRef(ResultDataReference* ref);

		/**
		 * @brief Attaches all instances that have the desired id set as this one.
		 *
		 * @return Amount of attached instances.
		 */
		ResultData::size_type attachDesired();

		/**
		 * @brief Enables or disables recycling mode and flag. Does not generate an event.
		 *
		 * @param recycle
		 * @return True on success.
		 */
		bool recycleEnable(bool recycle);

		/**
		 * @brief Reference to the actual data
		 */
		ResultDataReference* _reference{nullptr};
		/**
		 * @brief Pointer to ResultDataEventHandler function
		 */
		ResultDataHandler* _handler{nullptr};
		/**
		 * @brief This transfer ID member identifies this instance when an
		 * event is generated for a specific result as a result of a request made by this specific result.
		 * This value is set and reset  by the 'setHandler' member function.
		 */
		Range::id_type _transactionId{0};
		/**
		 * @brief If this data member is non-zero it will be automatically re-attached to the reference when it is created.
		 */
		id_type _desiredId{0};
		/**
		 * @brief Hold the pointer to any data assigned by using #setUserData.
		 */
		void* _userData{nullptr};
		/**
		 * @brief Holds the instance data for user purposes set with #setData() and got with getData().
		 */
		uint64_t _data{0};

	public:
		/**
		 * @brief Sets the debug flag for this instance reference.
		 *
		 * @param debug True to enable.
		 */
		void setDebug(bool debug);
		/**
		 * @brief Gets the debug flag of the instance reference.
		 *
		 * @return True when enabled.
		 */
		[[nodiscard]] bool isDebug() const;
		/**
		 * @brief Gets the name of the passed #EEvent number.
		 * @param event The event number.
		 * @return String with name.
		 */
		static const char* getEventName(EEvent event);

		/**
		 * @brief Gets the underlying reference class of this instance.
		 * @return Reference class.
		 */
		const ResultDataReference& getReference()
		{
			return *_reference;
		}

		/**
		 * @brief Gets the a vector of ranges still to be committed.
		 * @return Vector of ranges.
		 */
		[[nodiscard]] const Range::Vector& getCommitList() const;

		/**
		 * @brief Gets the a vector of ranges that are validated.
		 * @return Vector of ranges.
		 */
		[[nodiscard]] const Range::Vector& getValidatedList() const;

		/**
		 * @brief Returns the accumulation of locks on segments.
		 */
		[[nodiscard]] size_type getSegmentLocks() const;

		/**
		 * @brief Initiate event for all instances of this result.
		 * If skip_self is 'true' this instance is left out of the list.
		 * @param event
		 * @param rng
		 * @param skip_self
		 * @return
		 */
		size_type emitEvent(EEvent event, const Range& rng, bool skip_self = false);

		friend class ResultDataHandler;

		friend class ResultDataReference;

		friend class ResultDataStatic;
};

inline
ResultData::ResultData(const ResultData& rd)
{
	setup(rd);
}

inline
ResultData::ResultData(ResultData::id_type id, bool set_desired)
{
	setup(id, set_desired);
}

inline
ResultData::ResultData(const std::string& definition, ResultData::id_type id_ofs)
{
	setup(definition, id_ofs);
}

inline
ResultData::ResultData(const Definition& definition, ResultData::id_type id_ofs)
{
	setup(definition, id_ofs);
}

inline
bool ResultData::setup(const std::string& definition, id_type id_ofs)
{
	return setup(getDefinition(definition), id_ofs);
}

inline
bool ResultData::setup(const ResultData& rd)
{
	setDesiredId(rd._desiredId);
	return attachRef(rd._reference);
}

inline
bool ResultData::setup(ResultData::id_type id, bool set_did)
{
	if (set_did)
	{
		setDesiredId(id);
	}
	return attachRef(getReferenceById(id));
}

inline
ResultData& ResultData::operator=(const ResultData& rd)
{
	if (this != &rd)
	{
		setup(rd);
	}
	return *this;
}

inline
void ResultData::setUserData(void* data)
{
	_userData = data;
}

inline
void* ResultData::getUserData() const
{
	return _userData;
}

inline
ResultData::id_type ResultData::getDesiredId() const
{
	return _desiredId;
}

inline
ResultData::size_type ResultData::getBufferSize(const Range& rng) const
{
	return getBufferSize(rng.getSize());
}

inline
bool ResultData::blockRead(const Range& rng, void* dest, bool force) const
{
	return blockRead(rng.getStart(), rng.getSize(), dest, force);
}

inline
bool ResultData::blockWrite(const Range& rng, const void* src, bool auto_reserve)
{
	return blockWrite(rng.getStart(), rng.getSize(), src, auto_reserve);
}

inline
Range::id_type ResultData::getTransId() const
{
	return _transactionId;
}

inline
void ResultData::validateRange(Range::size_type ofs, Range::size_type sz)
{
	validateRange(Range(ofs, ofs + sz));
}

inline
bool ResultData::requestRange(Range::size_type ofs, Range::size_type sz)
{
	return requestRange(Range(ofs, ofs + sz));
}

inline
bool ResultData::setAccessRange(Range::size_type stop, bool skip_self)
{
	return ResultData::setAccessRange(Range(0, stop), skip_self);
}

inline
ResultData::size_type ResultData::getTypeSize() const
{
	return getTypeSize(getType());
}

inline
void ResultData::setData(uint64_t data)
{
	_data = data;
}

inline
uint64_t ResultData::getData() const
{
	return _data;
}

inline
bool ResultData::isDebug() const
{
	return _reference && _reference->_debug;
}

inline
bool ResultData::operator==(const ResultData& rd) const
{
	return rd._reference == _reference && rd.isOwner() == isOwner();
}

/**
 * @brief Stream operator for the setup std::string.
 */
_GII_FUNC std::ostream& operator<<(std::ostream& os, const ResultData&);

/**
 * @brief Stream operator for setting up this instance with a setup std::string.
 */
_GII_FUNC  std::istream& operator>>(std::istream& is, ResultData&);

}
